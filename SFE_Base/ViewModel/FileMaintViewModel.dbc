;;**********************************************************************
;;
;; Title:       FileMaintViewModel.dbc
;;
;; Type:        Class
;;
;; Description: Base/generic Maintenance View Model
;;
;; Author:      Richard C. Morris, Synergex Technology Evangelist
;;
;; Copyright (c) 2012, Synergex International, Inc. All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************
import System
import System.Collections.Generic
import System.Text
import Symphony.Conductor.ViewModel
import System.Windows
import Symphony.Conductor.Model
import Symphony.Conductor.DataIO
import System.Collections.ObjectModel
import System.Reflection
import System.Linq
import Symphony.Conductor.Types
import Symphony.Conductor.Commands


namespace SFE_Base.ViewModel
	

	public class FileMaintViewModel extends BaseViewModel
		
		; constructor for no detail lines
		public method FileMaintViewModel
		in req sender				,@FrameworkElement
		in req dataItem				,@Type
		in req fileAccess			,@FileIO
		in req errorVisualState		,string
		endparams
		parent(sender)
		proc
			
			;;store the passed info
			mDataObjectItem = dataItem
			mFileAccessObject = fileAccess
			mErrorVisualState = errorVisualState
			
			this.AfterNavigateState += doAfterStateNavigation

			;;create our base collection
			DataObjectCollection = new AsyncObservableCollection<DataObjectBase>()

			mNumberOfDetailLineSets = 0

		endmethod

		; constructor for 1 set fo detail lines
		
		public method FileMaintViewModel
		in req sender						,@FrameworkElement
		in req dataItem						,@Type
		in req fileAccess					,@FileIO
		in req errorVisualState				,string
		in req detailItem					,@Type
		endparams
		parent(sender)
		proc
			
			;;store the passed info
			mDataObjectItem = dataItem
			mDataObjectDetailItem = detailItem 
			mFileAccessObject = fileAccess
			mErrorVisualState = errorVisualState
			
			this.AfterNavigateState += doAfterStateNavigation

			;;create our base collection
			DataObjectCollection = new AsyncObservableCollection<DataObjectBase>()
			DataObjectDetailCollection = new AsyncObservableCollection<DataObjectBase>()

			mNumberOfDetailLineSets = 1

		endmethod


		private mNumberOfDetailLineSets		,int


.region "List controlling and loading methods"
		
		public method LoadDetailList		,void
		endparams
		proc
			;;if we have a valid file object let's load the initial list
			if (!mFileAccessObject.LastSynergyError)
				LoadBaseItemCollection()
		endmethod

.endregion

.region "Visual state details"
		
		private mErrorVisualState		,string

		private method doAfterStateNavigation,void
		eArgs		,@Symphony.Conductor.ViewModel.NavigateFromStateEventArgs 
		endparams
		proc
			if (eArgs.CurrentStateName == mErrorVisualState)
			begin
				doCancelCommand(^null, "")
			end
		endmethod

.endregion
		
.region "Event processing"
		
		public delegate ProgramModeChangedEventandler,void
		in req currentMode					,ProgramMode
		enddelegate
		
		public event ProgramModeChanged		,@ProgramModeChangedEventandler
		
		private method raiseProgramModeChanged,void
		endparams
		proc
			if (mLastProgramMode != mProgramMode)
			begin
				mLastProgramMode = mProgramMode
				raiseevent(ProgramModeChanged, mProgramMode)
			end
		endmethod


		public delegate ProgramDetailModeChangedEventandler,void
		in req currentDetailMode					,ProgramMode
		enddelegate
		
		public event ProgramDetailModeChanged		,@ProgramDetailModeChangedEventandler
		
		private method raiseProgramDetailModeChanged,void
		endparams
		proc
			if (mLastProgramDetailMode != mProgramDetailMode)
			begin
				mLastProgramDetailMode = mProgramDetailMode
				raiseevent(ProgramDetailModeChanged, mProgramDetailMode)
			end
		endmethod
		
.endregion
		
.region "private class members"
		
		private mDataObjectItem				,@Type
		private mFileAccessObject			,@FileIO

		private mDataObjectDetailItem		,@Type
		private mDetailClassConstructor		,@ConstructorInfo
		private mDetailCTORArgs				,[#]@Object		,new Object[1]
.endregion
		
.region "load base item list"
		
		private mClassConstructor			,@ConstructorInfo
		private mCTORArgs					,[#]@Object		,new Object[1]

		public virtual method LoadBaseItemCollection,void
		endparams
		proc
			
		data firstTime							,boolean				,true
			
		data classTypeInfo						,@TypeInfo				,IntrospectionExtensions.GetTypeInfo(mDataObjectItem)
			if (classTypeInfo != ^null)
			begin
			data item							,@ConstructorInfo
				foreach item in classTypeInfo.DeclaredConstructors
				begin
					mClassConstructor = item
					if (mClassConstructor.ToString() == "Void .ctor(System.String)")
						exitloop
				end
				
				mCTORArgs[1] = ""
				
				mDataObjectEntryItem = (DataObjectBase)mClassConstructor.Invoke(mCTORArgs)
				
				;;bind the required handlers
				mDataObjectEntryItem.IsDataModifiedChanged += DoIsDataModified
				
				
			data status							,FileAccessResults		,FileAccessResults.Success
				while (status == FileAccessResults.Success)
				begin
				data classInstance = mClassConstructor.Invoke(mCTORArgs)
					
					if (firstTime) then
						status = mFileAccessObject.ReadFirstRecord((DataObjectBase)classInstance)
					else
						status = mFileAccessObject.ReadNextRecord((DataObjectBase)classInstance)
					
					firstTime = false
					
					if (status == FileAccessResults.Success)
					begin
						
						DataObjectCollection.AddToCollection((DataObjectBase)classInstance)
					end
				end
			end
		endmethod
		
		public property DataObjectCollection	,@AsyncObservableCollection<DataObjectBase>
			method get
			endmethod
			method set
			endmethod
		endproperty
		
		private mSelectedItemIndex				,int
		
		public property SelectedItemIndex		,int
			method get
			proc
				mreturn mSelectedItemIndex
			endmethod
			method set
			proc
				mSelectedItemIndex = value

				; master record in list selected.  Now load the DataObjectDetailCollection

				RaisePropertyChanged("SelectedItemIndex")
			endmethod
		endproperty
		
		private mIgnoreDetailDataChanged			,boolean

		
		private mSelectedCollectionItem				,@DataObjectBase
		
		public property SelectedCollectionItem		,@DataObjectBase
			method get
			proc
				mreturn mSelectedCollectionItem
			endmethod
			method set
			proc
				mProgramMode = ProgramMode.Enquiry
				if (value != ^null) then
				begin
					mSelectedCollectionItem = value


					mDataObjectEntryItem.SynergyRecord = mSelectedCollectionItem.SynergyRecord
					mDataObjectEntryItem.OriginalSynergyRecord = mSelectedCollectionItem.SynergyRecord


					LoadDetailLines()

					DetailGridIsEnabled = true

					SelectedDetailItemIndex = 0

					raiseProgramModeChanged()
				end
				else
				begin
					mSelectedCollectionItem = value
					NewCommand.ExecuteState = true
					SaveCommand.ExecuteState = false
					CancelCommand.ExecuteState = false
					DeleteCommand.ExecuteState = false

				end

				NewDetailCommand.ExecuteState = true
				SaveDetailCommand.ExecuteState = false
				CancelDetailCommand.ExecuteState = false
				DeleteDetailCommand.ExecuteState = true

				raiseProgramModeChanged()
				RaisePropertyChanged("SelectedCollectionItem")



			endmethod
		endproperty
		
		private mDataObjectEntryItem			,@DataObjectBase
		
		public property DataObjectEntryItem		,@DataObjectBase
			method get
			proc
				mreturn mDataObjectEntryItem
			endmethod
			method set
			proc
				mDataObjectEntryItem = value
			endmethod
		endproperty
		
.endregion
		


.region 'detail lines'
		public property DataObjectDetailCollection		,@AsyncObservableCollection<DataObjectBase>
			method get
			endmethod
			method set
			endmethod
		endproperty
		
		private mSelectedDetailItemIndex			,int
		
		public property SelectedDetailItemIndex		,int
			method get
			proc
				mreturn mSelectedDetailItemIndex
			endmethod
			method set
			proc
				mSelectedDetailItemIndex = value
				RaisePropertyChanged("SelectedDetailItemIndex")
			endmethod
		endproperty
		
		
		private mSelectedDetailCollectionItem			,@DataObjectBase
		
		public property SelectedDetailCollectionItem	,@DataObjectBase
			method get
			proc
				mreturn mSelectedDetailCollectionItem
			endmethod
			method set
			proc
				mProgramDetailMode = ProgramMode.Enquiry
				if (value != ^null) then
				begin
					mSelectedDetailCollectionItem = value
					mIgnoreDetailDataChanged = true
					mDataObjectDetailEntryItem.SynergyRecord			= mSelectedDetailCollectionItem.SynergyRecord
					mDataObjectDetailEntryItem.OriginalSynergyRecord	= mSelectedDetailCollectionItem.SynergyRecord
					mIgnoreDetailDataChanged = false
					DeleteDetailCommand.ExecuteState = true
					CancelDetailCommand.ExecuteState = false
					RaisePropertyChanged(^null)

				end
				else
				begin
					mSelectedDetailCollectionItem = value
					NewDetailCommand.ExecuteState = true
					SaveDetailCommand.ExecuteState = false
					CancelDetailCommand.ExecuteState = false
					DeleteDetailCommand.ExecuteState = false
					raiseProgramDetailModeChanged()
				end

				RaisePropertyChanged("SelectedDetailCollectionItem")

			endmethod
		endproperty
		
		private mDataObjectDetailEntryItem				,@DataObjectBase
		
		public property DataObjectDetailEntryItem		,@DataObjectBase
			method get
			proc
				mreturn mDataObjectDetailEntryItem
			endmethod
			method set
			proc
				mDataObjectDetailEntryItem = value
			endmethod
		endproperty
		

		; this will always be overridden in the vie wmodel to perform specific processing
		public virtual method LoadDetailLines,void
		proc
			nop
		endmethod

		
.endregion 


.region "Data entry event handlers"
		
		private mProgramMode		,ProgramMode
		private mLastProgramMode	,ProgramMode


		
		public method DoIsDataModified,void
		endparams
		proc
			GridIsEnabled = !mDataObjectEntryItem.IsDataModified
			SaveCommand.ExecuteState = mDataObjectEntryItem.IsDataModified && mDataObjectEntryItem.IsDataValid
			CancelCommand.ExecuteState = mDataObjectEntryItem.IsDataModified
			DeleteCommand.ExecuteState = SelectedCollectionItem != ^null && !mDataObjectEntryItem.IsDataModified
			NewCommand.ExecuteState = !mDataObjectEntryItem.IsDataModified
			if (mDataObjectEntryItem.IsDataModified && mDataObjectEntryItem.IsDataValid && mProgramMode == ProgramMode.Enquiry)
			begin
				mProgramMode = ProgramMode.Modify
				raiseProgramModeChanged()
			end
		endmethod

		private mProgramDetailMode			,ProgramMode
		private mLastProgramDetailMode		,ProgramMode


		public method DoIsDetailDataModified,void
		endparams
		proc
			if (!mIgnoreDetailDataChanged)
			begin

				DetailGridIsEnabled = !mDataObjectDetailEntryItem.IsDataModified
				SaveDetailCommand.ExecuteState = mDataObjectDetailEntryItem.IsDataModified && mDataObjectDetailEntryItem.IsDataValid
				CancelDetailCommand.ExecuteState = mDataObjectDetailEntryItem.IsDataModified
				DeleteDetailCommand.ExecuteState = SelectedDetailCollectionItem != ^null && !mDataObjectDetailEntryItem.IsDataModified
				NewDetailCommand.ExecuteState = !mDataObjectDetailEntryItem.IsDataModified
				if (mDataObjectDetailEntryItem.IsDataModified && mDataObjectDetailEntryItem.IsDataValid && mProgramDetailMode == ProgramMode.Enquiry)
				begin
					mProgramDetailMode = ProgramMode.Modify
					raiseProgramDetailModeChanged()
				end

				if (!mDetailGridIsEnabled)
				begin
					GridIsEnabled = false
					NewCommand.ExecuteState = false
					DeleteCommand.ExecuteState = false
					CancelCommand.ExecuteState = true
					SaveCommand.ExecuteState = false
				end

			end


		endmethod

.endregion
		
.region "Standard commands"
		
		private mNewCommand				,@GenericCommand
		
		public property NewCommand		,@GenericCommand
			method get
			proc
				if (mNewCommand == ^null)
				begin
					mNewCommand = new GenericCommand("NEW", doNewCommand)
					mNewCommand.ExecuteState = true
				end
				mreturn mNewCommand
			endmethod
		endproperty
		
		private method doNewCommand,void
		sender							,@Object
		param							,string
		endparams
		proc
			DataObjectEntryItem.InitData()
			DataObjectEntryItem.InitDataPlus()
			DataObjectEntryItem.InitialValidateData()

			if (mNumberOfDetailLineSets)
			begin
				DataObjectDetailEntryItem.InitData()
				DataObjectDetailEntryItem.InitDataPlus()
				DataObjectDetailEntryItem.InitialValidateData()
				DataObjectDetailCollection.ClearCollection()
			end

			NewCommand.ExecuteState = false
			DataObjectEntryItem.SetFieldEnabledStatus(true, "*ALL*")
			mProgramMode = ProgramMode.Add
			raiseProgramModeChanged()
		endmethod
		
		private mSaveCommand			,@GenericCommand
		
		public property SaveCommand		,@GenericCommand
			method get
			proc
				if (mSaveCommand == ^null)
				begin
					mSaveCommand = new GenericCommand("SAVE", doSaveCommand)
					mSaveCommand.ExecuteState = false
				end
				mreturn mSaveCommand
			endmethod
		endproperty
		
		private method doSaveCommand,void
		sender								,@Object
		param								,string
		endparams
		proc

			using mProgramMode select
			(ProgramMode.Modify)			,
			begin
				;;restore the data to the colleciton item and update the file.
				SelectedCollectionItem.SynergyRecord = DataObjectEntryItem.SynergyRecord
				if (mFileAccessObject.UpdateRecordUsingGRFA(SelectedCollectionItem) != FileAccessResults.Success)
				begin
					mDataObjectEntryItem.RestoreOriginalData()
					ErrorInfo = "Synergy error : " + %string(mFileAccessObject.LastSynergyError)
					using (mFileAccessObject.LastSynergyError) select
					(54)					,ErrorDetails = ' You are trying to add a record with a key which already exists - please use a different code.'
					(431)					,ErrorDetails = 'Someone else has updated this record before you saved your changes.  Your changes have been lost.  Please try again.'
					(40)					,ErrorDetails = 'Another program is holding this record locked and your changes cannot be saved.  Please try again.'
					()						,ErrorDetails = 'Your changes have not been saved.  Please try again and refer to support if the problem persists.'
					endusing

					MoveToState(mErrorVisualState)
				end

				SaveDetailLines()

				DataObjectEntryItem.OriginalSynergyRecord = SelectedCollectionItem.SynergyRecord 
				mDataObjectEntryItem.RestoreOriginalData()
			end
			(ProgramMode.Add)				,
			begin
			data tmpObj						,@DataObjectBase
				mCTORArgs[1] = DataObjectEntryItem.SynergyRecord

				if (mClassConstructor == ^null)
				begin
					;;we did not use the standard/base list load capability

				data classTypeInfo			,@TypeInfo		,IntrospectionExtensions.GetTypeInfo(mDataObjectItem)
				data item					,@ConstructorInfo
					foreach item in classTypeInfo.DeclaredConstructors
					begin
						mClassConstructor = item
						if (mClassConstructor.ToString() == "Void .ctor(System.String)")
							exitloop
					end
				end
				tmpObj = (DataObjectBase)mClassConstructor.Invoke(mCTORArgs)
	
				if (mFileAccessObject.CreateRecord(tmpObj) != FileAccessResults.Success) then
				begin
					ErrorInfo = "Synergy error : " + %string(mFileAccessObject.LastSynergyError)
					using (mFileAccessObject.LastSynergyError) select
					(54)					,ErrorDetails = ' You are trying to add a record with a key which already exists - please use a different code.'
					(431)					,ErrorDetails = 'Someone else has updated this record before you saved your changes.  Your changes have been lost.  Please try again.'
					(40)					,ErrorDetails = 'Another program is holding this record locked and your changes cannot be saved.  Please try again.'
					()						,ErrorDetails = 'Your changes have not been saved.  Please try again and refer to support if the problem persists.'
					endusing
					MoveToState(mErrorVisualState)
				end
				else
				begin
					AddDetailLines()
					DataObjectCollection.AddToCollection(tmpObj)
					DataObjectEntryItem.OriginalSynergyRecord = DataObjectEntryItem.SynergyRecord 
					mDataObjectEntryItem.RestoreOriginalData()
					SelectedCollectionItem = tmpObj
				end
			end
			endusing

			raiseProgramModeChanged()
			GridIsEnabled = true
			NewCommand.ExecuteState = true
			SaveCommand.ExecuteState = false
			CancelCommand.ExecuteState = false
			DeleteCommand.ExecuteState = true
			mProgramMode = ProgramMode.Enquiry

		endmethod
		
		private mCancelCommand				,@GenericCommand
		
		public property CancelCommand		,@GenericCommand
			method get
			proc
				if (mCancelCommand == ^null)
				begin
					mCancelCommand = new GenericCommand("CANCEL", doCancelCommand)
					mCancelCommand.ExecuteState = false
				end
				mreturn mCancelCommand
			endmethod
		endproperty
		
		private method doCancelCommand,void
		sender								,@Object
		param								,string
		endparams
		proc
			mProgramMode = ProgramMode.Enquiry
			raiseProgramModeChanged()
			mDataObjectEntryItem.RestoreOriginalData()
			mDataObjectEntryItem.InitialValidateData()
			mDataObjectEntryItem.RestoreOriginalData()
			NewCommand.ExecuteState = true
			SaveCommand.ExecuteState = false
			CancelCommand.ExecuteState = false
			DeleteCommand.ExecuteState = true
			GridIsEnabled = true

		endmethod
		
		private mDeleteCommand				,@GenericCommand
		
		public property DeleteCommand		,@GenericCommand
			method get
			proc
				if (mDeleteCommand == ^null)
				begin
					mDeleteCommand = new GenericCommand("DELETE", doDeleteCommand)
					mDeleteCommand.ExecuteState = false
				end
				mreturn mDeleteCommand
			endmethod
		endproperty
		
		private method doDeleteCommand,void
		sender		,@Object
		param		,string
		endparams
		proc
			if (SelectedCollectionItem != ^null)
			begin

				if (mFileAccessObject.DeleteRecordUsingGRFA(SelectedCollectionItem) != FileAccessResults.Success) then
				begin
					ErrorInfo = "Synergy error : " + %string(mFileAccessObject.LastSynergyError)
					MoveToState(mErrorVisualState)
				end
				else
				begin
					;;remove the item from the list

					DeleteDetailLines ()

					DataObjectCollection.Remove(SelectedCollectionItem)
					SelectedItemIndex  = 0
					
					;;init the entry object
;					DataObjectEntryItem.InitData()
					GridIsEnabled = true
				end
				mProgramMode = ProgramMode.Enquiry
				raiseProgramModeChanged()
				SaveCommand.ExecuteState = false
				CancelCommand.ExecuteState = false
				DeleteCommand.ExecuteState = true
				NewCommand.ExecuteState = true
				GridIsEnabled = true
			end
		endmethod
	


		; dummy method which can be overridden in view models which require the ability to update detail lines
		public virtual method SaveDetailLines,void

		endparams
		proc
			nop
		endmethod

		; dummy method which can be overridden in view models which require the ability to update detail lines
		public virtual method AddDetailLines,void

		endparams
		proc
			nop
		endmethod

		; dummy method which can be overridden in view models which require the ability to update detail lines
		public virtual method DeleteDetailLines,void

		endparams
		proc
			nop
		endmethod

		
.endregion

;---------------------------------------- detail lines ------------------------------------------------------------------------	
.region "detail line commands"
		
		private mNewDetailCommand			,@GenericCommand
		
		public property NewDetailCommand	,@GenericCommand
			method get
			proc
				if (mNewDetailCommand == ^null)
				begin
					mNewDetailCommand = new GenericCommand("NEW", doNewDetailCommand)
					mNewDetailCommand.ExecuteState = true
				end
				mreturn mNewDetailCommand
			endmethod
		endproperty
		
		private method doNewDetailCommand,void
		sender									,@Object
		param									,string
		endparams
		proc
			DataObjectDetailEntryItem.InitData()
			DataObjectDetailEntryItem.InitDataPlus()
			DataObjectDetailEntryItem.InitialValidateData()
			NewDetailCommand.ExecuteState = false
			DataObjectDetailEntryItem.SetFieldEnabledStatus(true, "*ALL*")
			mProgramDetailMode = ProgramMode.Add
			mDeleteDetailCommand.ExecuteState = false
			mSaveDetailCommand.ExecuteState = false
			mCancelDetailCommand.ExecuteState = true		
			raiseProgramDetailModeChanged()

		endmethod
		
		private mSaveDetailCommand				,@GenericCommand
		
		public property SaveDetailCommand		,@GenericCommand
			method get
			proc
				if (mSaveDetailCommand == ^null)
				begin
					mSaveDetailCommand = new GenericCommand("SAVE", doSaveDetailCommand)
					mSaveDetailCommand.ExecuteState = false
				end
				mreturn mSaveDetailCommand
			endmethod
		endproperty
		
		private method doSaveDetailCommand,void
		sender									,@Object
		param									,string
		endparams
		proc

			using mProgramDetailMode select
			(ProgramMode.Modify)				,
			begin
				;;restore the data to the colleciton item
				SelectedDetailCollectionItem.SynergyRecord = DataObjectDetailEntryItem.SynergyRecord
				DataObjectDetailEntryItem.OriginalSynergyRecord = SelectedDetailCollectionItem.SynergyRecord 
				mDataObjectDetailEntryItem.RestoreOriginalData()
			end

			(ProgramMode.Add)					,
			begin
			data tmpObj							,@DataObjectBase
				 
				mDetailCTORArgs[1] = DataObjectDetailEntryItem.SynergyRecord

				if (mDetailClassConstructor == ^null)
				begin
					;;we did not use the standard/base list load capability

				data classTypeInfo				,@TypeInfo		,IntrospectionExtensions.GetTypeInfo(mDataObjectDetailItem)
				data item						,@ConstructorInfo
					foreach item in classTypeInfo.DeclaredConstructors
					begin
						mDetailClassConstructor = item
						if (mDetailClassConstructor.ToString() == "Void .ctor(System.String)")
							exitloop
					end	
				end	
				tmpObj = (DataObjectBase)mDetailClassConstructor.Invoke(mDetailCTORArgs)
				DataObjectDetailCollection.AddToCollection(tmpObj)
					
				DataObjectDetailEntryItem.OriginalSynergyRecord = DataObjectDetailEntryItem.SynergyRecord 
				mDataObjectDetailEntryItem.RestoreOriginalData()
				SelectedDetailCollectionItem = tmpObj
				SelectedDetailItemIndex = DataObjectDetailCollection.Count

;				DataObjectDetailCollection.AddToCollection(DataObjectDetailEntryItem)
;				DataObjectDetailEntryItem.OriginalSynergyRecord = DataObjectDetailEntryItem.SynergyRecord 
;				mDataObjectDetailEntryItem.RestoreOriginalData()
;				SelectedDetailCollectionItem = DataObjectDetailEntryItem
;				SelectedDetailItemIndex = DataObjectDetailCollection.Count
			end
			endusing
			
			

			if (SelectedDetailItemIndex >= 0) then
			begin
				DeleteDetailCommand.ExecuteState = true
				SaveDetailCommand.ExecuteState = false
				CancelDetailCommand.ExecuteState = false
			end
			else
			begin
				DeleteDetailCommand.ExecuteState = false
				SaveDetailCommand.ExecuteState = false
				CancelDetailCommand.ExecuteState = false
			end
			NewDetailCommand.ExecuteState = true
			mProgramDetailMode = ProgramMode.Enquiry
			raiseProgramDetailModeChanged()
			DetailGridIsEnabled = true

			if (mDataObjectEntryItem.IsDataValid)
				SaveCommand.ExecuteState = true
			CancelCommand.ExecuteState = true
			NewCommand.ExecuteState = false
			DeleteCommand.ExecuteState= false
			GridIsEnabled = false

		endmethod
		

		private mCancelDetailCommand			,@GenericCommand
		
		public property CancelDetailCommand		,@GenericCommand
			method get
			proc
				if (mCancelDetailCommand == ^null)
				begin
					mCancelDetailCommand = new GenericCommand("CANCEL", doCancelDetailCommand)
					mCancelDetailCommand.ExecuteState = false
				end
				mreturn mCancelDetailCommand
			endmethod
		endproperty
		
		private method doCancelDetailCommand,void
		sender									,@Object
		param									,string
		endparams
		proc
			mDataObjectDetailEntryItem.RestoreOriginalData()
			mDataObjectDetailEntryItem.InitialValidateData()
			mDataObjectDetailEntryItem.RestoreOriginalData()

			NewDetailCommand.ExecuteState = true

;			if (SelectedDetailItemIndex) then
;			begin
;				DeleteDetailCommand.ExecuteState = true
;				SaveDetailCommand.ExecuteState = false
;				CancelDetailCommand.ExecuteState = false
;			end
;			else
;			begin
			DeleteDetailCommand.ExecuteState = true
			SaveDetailCommand.ExecuteState = false
			CancelDetailCommand.ExecuteState = false
;			end

			NewDetailCommand.ExecuteState = true
			DetailGridIsEnabled = true
			mProgramDetailMode = ProgramMode.Enquiry
			raiseProgramDetailModeChanged()
		endmethod
		
		private mDeleteDetailCommand			,@GenericCommand
		
		public property DeleteDetailCommand		,@GenericCommand
			method get
			proc
				if (mDeleteDetailCommand == ^null)
				begin
					mDeleteDetailCommand = new GenericCommand("DELETE", doDeleteDetailCommand)
					mDeleteDetailCommand.ExecuteState = false
				end
				mreturn mDeleteDetailCommand
			endmethod
		endproperty
		
		private method doDeleteDetailCommand,void
		sender								,@Object
		param								,string
		endparams
		proc
			if (SelectedDetailCollectionItem != ^null)
			begin
;					;;remove the item from the list
				DataObjectDetailCollection.Remove(SelectedDetailCollectionItem)
				SelectedDetailCollectionItem  = ^null
					
				;;init the entry object
				DataObjectDetailEntryItem.InitData()

			end

			if (SelectedDetailItemIndex) then
			begin
				DeleteDetailCommand.ExecuteState = true
				SaveDetailCommand.ExecuteState = false
				CancelDetailCommand.ExecuteState = false
			end
			else
			begin
				DeleteDetailCommand.ExecuteState = false
				SaveDetailCommand.ExecuteState = false
				CancelDetailCommand.ExecuteState = false
			end
			NewDetailCommand.ExecuteState = true
			DetailGridIsEnabled = true			
			SaveCommand.ExecuteState = true
			CancelCommand.ExecuteState = true
			NewCommand.ExecuteState = false
			DeleteCommand.ExecuteState= false
			GridIsEnabled = false

			mProgramDetailMode = ProgramMode.Enquiry
			raiseProgramDetailModeChanged()

		endmethod

.endregion

		
.region "list/grid options"
		
		private mGridIsEnabled				,boolean		,true
		
		public property GridIsEnabled		,boolean
			method get
			proc
				mreturn mGridIsEnabled
			endmethod
			method set
			proc
				if (mGridIsEnabled != value)
				begin
					mGridIsEnabled = value
					RaisePropertyChanged("GridIsEnabled")
				end
			endmethod
		endproperty


		private mDetailGridIsEnabled			,boolean		,true
		
		public property DetailGridIsEnabled		,boolean
			method get
			proc
				mreturn mDetailGridIsEnabled
			endmethod
			method set
			proc
				if (mDetailGridIsEnabled != value)
				begin
					mDetailGridIsEnabled = value
					RaisePropertyChanged("DetailGridIsEnabled")
				end
			endmethod
		endproperty
		
		
.endregion
		
.region "Error information"
		
		private mErrorInfo				,string
		
		public property ErrorInfo		,string
			method get
			proc
				mreturn mErrorInfo
			endmethod
			method set
			proc
				mErrorInfo = value
				RaisePropertyChanged("ErrorInfo")
			endmethod
		endproperty
		
		private mErrorDetails			,string
		
		public property ErrorDetails	,string
			method get
			proc
				mreturn mErrorDetails
			endmethod
			method set
			proc
				mErrorDetails = value
				RaisePropertyChanged("ErrorDetails")
			endmethod
		endproperty	
.endregion
	endclass
	
endnamespace
