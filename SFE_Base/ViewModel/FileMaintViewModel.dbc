;;**********************************************************************
;;
;; Title:       FileMaintViewModel.dbc
;;
;; Type:        Class
;;
;; Description: Base/generic Maintenance View Model
;;
;; Author:      Richard C. Morris, Synergex Technology Evangelist
;;
;; Copyright (c) 2012, Synergex International, Inc. All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************
import System
import System.Collections.Generic
import System.Text
import Symphony.Conductor.ViewModel
import System.Windows
import Symphony.Conductor.Model
import Symphony.Conductor.DataIO
import System.Collections.ObjectModel
import System.Reflection
import System.Linq
import Symphony.Conductor.Types
import Symphony.Conductor.Commands


namespace SFE_Base.ViewModel
	

	public class FileMaintViewModel extends BaseViewModel
		
		; constructor for no detail lines
		public method FileMaintViewModel
			in req sender				,@FrameworkElement
			in req dataItem				,@Type
			in req fileAccess			,@FileIO
			in req errorVisualState		,string
			in dialogVisualState		,string
			endparams
			parent(sender)
		proc
			constructorLogic(sender, dataItem, fileAccess, errorVisualState, ^null, dialogVisualState)

		endmethod

		; constructor for 1 set fo detail lines
		
		public method FileMaintViewModel
			in req sender						,@FrameworkElement
			in req dataItem						,@Type
			in req fileAccess					,@FileIO
			in req errorVisualState				,string
			in req detailItem					,@Type
			in dialogVisualState				,string
			endparams
			parent(sender)
		proc

			constructorLogic(sender, dataItem, fileAccess, errorVisualState, detailItem, dialogVisualState)

		endmethod

		private method constructorLogic, void
			in req sender						,@FrameworkElement
			in req dataItem						,@Type
			in req fileAccess					,@FileIO
			in req errorVisualState				,string
			in req detailItem					,@Type
			in req dialogVisualState			,string
			endparams
		proc
			configureDialog(sender)

			;;store the passed info
			mDataObjectItem = dataItem
			mDataObjectDetailItem = detailItem 
			mFileAccessObject = fileAccess
			mErrorVisualState = errorVisualState
			if  (!string.IsNullOrEmpty(dialogVisualState))
				mDialogVisualState = dialogVisualState
			
			this.AfterNavigateState += doAfterStateNavigation

			;;create our base collection
			DataObjectCollection = new AsyncObservableCollection<DataObjectBase>()

			mNumberOfDetailLineSets = 0
			if (detailItem != ^null)
			begin
				DataObjectDetailCollection = new AsyncObservableCollection<DataObjectBase>()
				mNumberOfDetailLineSets = 1
			end
			
		endmethod

		private mNumberOfDetailLineSets		,int


.region "List controlling and loading methods"
		
		public method LoadDetailList		,void
			endparams
		proc
			;;if we have a valid file object let's load the initial list
			if (!mFileAccessObject.LastSynergyError)
				LoadBaseItemCollection()
		endmethod

.endregion

.region "Visual state details"
		
		private mErrorVisualState		,string		
		private mDialogVisualState		,string

		private method doAfterStateNavigation,void
			eArgs		,@Symphony.Conductor.ViewModel.NavigateFromStateEventArgs 
			endparams
		proc
			if (eArgs.CurrentStateName == mErrorVisualState)
			begin
				doCancelCommand(^null, "")
			end

			if (eArgs.OldStateName == mDialogVisualState)
			begin
				using mDialogResult select
				(DialogResult.No),
					doCancelCommand(^null, "")
				(DialogResult.Cancel),
					doCancelCommand(^null, "")
				(DialogResult.Yes),
					doDeleteCommand(^null, "")
				(DialogResult.Retry),
					nop
				(DialogResult.OK),
					nop
				(),
					nop
				endusing
			end
		endmethod

.endregion
		
.region "Event processing"
		
		public delegate ProgramModeChangedEventandler,void
			in req currentMode					,ProgramMode
		enddelegate
		
		public event ProgramModeChanged		,@ProgramModeChangedEventandler
		
		private method raiseProgramModeChanged,void
			endparams
		proc
			if (mLastProgramMode != mProgramMode)
			begin
				mLastProgramMode = mProgramMode
				raiseevent(ProgramModeChanged, mProgramMode)
			end

			mDialogResult = ^null
		endmethod


		public delegate ProgramDetailModeChangedEventandler,void
			in req currentDetailMode					,ProgramMode
		enddelegate
		
		public event ProgramDetailModeChanged		,@ProgramDetailModeChangedEventandler
		
		private method raiseProgramDetailModeChanged,void
			endparams
		proc
			if (mLastProgramDetailMode != mProgramDetailMode)
			begin
				mLastProgramDetailMode = mProgramDetailMode
				raiseevent(ProgramDetailModeChanged, mProgramDetailMode)
			end

		mDialogResult = ^null

		endmethod
		
.endregion
		
.region "private class members"
		
		private mDataObjectItem				,@Type
		private mFileAccessObject			,@FileIO

		private mDataObjectDetailItem		,@Type
		private mDetailClassConstructor		,@ConstructorInfo
		private mDetailCTORArgs				,[#]@Object		,new Object[1]
.endregion
		
.region "load base item list"
		
		private mClassConstructor			,@ConstructorInfo
		private mCTORArgs					,[#]@Object		,new Object[1]

		public virtual method LoadBaseItemCollection,void
			endparams
		proc
			
			data firstTime							,boolean				,true
			
			data classTypeInfo						,@TypeInfo				,IntrospectionExtensions.GetTypeInfo(mDataObjectItem)
			if (classTypeInfo != ^null)
			begin
				data item							,@ConstructorInfo
				foreach item in classTypeInfo.DeclaredConstructors
				begin
					mClassConstructor = item
					if (mClassConstructor.ToString() == "Void .ctor(System.String)")
						exitloop
				end
				
				mCTORArgs[1] = ""
				
				mDataObjectEntryItem = (DataObjectBase)mClassConstructor.Invoke(mCTORArgs)
				
				;;bind the required handlers
				mDataObjectEntryItem.IsDataModifiedChanged += DoIsDataModified
				
				
				data status							,FileAccessResults		,FileAccessResults.Success
				while (status == FileAccessResults.Success)
				begin
					data classInstance = mClassConstructor.Invoke(mCTORArgs)
					
					if (firstTime) then
						status = mFileAccessObject.ReadFirstRecord((DataObjectBase)classInstance)
					else
						status = mFileAccessObject.ReadNextRecord((DataObjectBase)classInstance)
					
					firstTime = false
					
					if (status == FileAccessResults.Success)
					begin
						
						DataObjectCollection.AddToCollection((DataObjectBase)classInstance)
					end
				end
			end
		endmethod
		
		public property DataObjectCollection	,@AsyncObservableCollection<DataObjectBase>
			method get
			endmethod
			method set
			endmethod
		endproperty
		
		private mSelectedItemIndex				,int
		
		public property SelectedItemIndex		,int
			method get
			proc
				mreturn mSelectedItemIndex
			endmethod
			method set
			proc
				mSelectedItemIndex = value

				; master record in list selected.  Now load the DataObjectDetailCollection

				RaisePropertyChanged("SelectedItemIndex")
			endmethod
		endproperty
		
		;-----these are set to avoid enableing and disabling fields fgagging up data is modified

		private mIgnoreDetailDataChanged			,boolean

		public property IgnoreDetailDataChanged		,boolean
			method get
			proc
				mreturn mIgnoreDetailDataChanged
			endmethod
			method set
			proc
				mIgnoreDetailDataChanged = value
			endmethod
		endproperty

		private mIgnoreDataChanged				,boolean

		public property IgnoreDataChanged		,boolean
			method get
			proc
				mreturn mIgnoreDataChanged
			endmethod
			method set
			proc
				mIgnoreDataChanged = value
			endmethod
		endproperty
		
		;--------------------------------------------------------------------------

		private mSelectedCollectionItem				,@DataObjectBase
		
		public property SelectedCollectionItem		,@DataObjectBase
			method get
			proc
				mreturn mSelectedCollectionItem
			endmethod
			method set
			proc


				if (value != ^null) then
				begin

					mSelectedCollectionItem = value

					mProgramMode = ProgramMode.Enquiry
					raiseProgramModeChanged()

					mIgnoreDataChanged = true
					mDataObjectEntryItem.SynergyRecord = mSelectedCollectionItem.SynergyRecord
					mDataObjectEntryItem.OriginalSynergyRecord = mSelectedCollectionItem.SynergyRecord
					mIgnoreDataChanged = false	
					
					LoadDetailLines()

					DetailGridIsEnabled = true

					SelectedDetailItemIndex = 0

					DeleteCommand.ExecuteState = true

				end
				else
				begin
					DeleteCommand.ExecuteState = false
				end

				NewCommand.ExecuteState = true
				SaveCommand.ExecuteState = false
				CancelCommand.ExecuteState = false

				if (mNumberOfDetailLineSets)
				begin
					NewDetailCommand.ExecuteState = true
					SaveDetailCommand.ExecuteState = false
					CancelDetailCommand.ExecuteState = false


					if (DataObjectDetailCollection.Count)
						DeleteDetailCommand.ExecuteState = true
				end

				RaisePropertyChanged("SelectedCollectionItem")



			endmethod
		endproperty
		
		private mDataObjectEntryItem			,@DataObjectBase
		
		public property DataObjectEntryItem		,@DataObjectBase
			method get
			proc
				mreturn mDataObjectEntryItem
			endmethod
			method set
			proc
				mDataObjectEntryItem = value
			endmethod
		endproperty
		
.endregion
		


.region 'detail lines'
		public property DataObjectDetailCollection		,@AsyncObservableCollection<DataObjectBase>
			method get
			endmethod
			method set
			endmethod
		endproperty
		
		private mSelectedDetailItemIndex			,int
		
		public property SelectedDetailItemIndex		,int
			method get
			proc
				mreturn mSelectedDetailItemIndex
			endmethod
			method set
			proc

				mProgramDetailMode = ProgramMode.Enquiry
				raiseProgramDetailModeChanged()
				mSelectedDetailItemIndex = value
				RaisePropertyChanged("SelectedDetailItemIndex")
			endmethod
		endproperty
		
		
		private mSelectedDetailCollectionItem			,@DataObjectBase
		
		public property SelectedDetailCollectionItem	,@DataObjectBase
			method get
			proc
				mreturn mSelectedDetailCollectionItem
			endmethod
			method set
			proc

				mProgramDetailMode = ProgramMode.Enquiry
				raiseProgramDetailModeChanged()
				if (value != ^null) then
				begin
					mSelectedDetailCollectionItem = value

					mIgnoreDetailDataChanged = true
					mDataObjectDetailEntryItem.SynergyRecord			= mSelectedDetailCollectionItem.SynergyRecord
					mDataObjectDetailEntryItem.OriginalSynergyRecord	= mSelectedDetailCollectionItem.SynergyRecord
					mIgnoreDetailDataChanged = false

					DeleteDetailCommand.ExecuteState = true
					CancelDetailCommand.ExecuteState = false
					RaisePropertyChanged(^null)

				end
				else
				begin
					mSelectedDetailCollectionItem = value
					NewDetailCommand.ExecuteState = true
					SaveDetailCommand.ExecuteState = false
					CancelDetailCommand.ExecuteState = false
					DeleteDetailCommand.ExecuteState = false
				end

				RaisePropertyChanged("SelectedDetailCollectionItem")

			endmethod
		endproperty
		
		private mDataObjectDetailEntryItem				,@DataObjectBase
		
		public property DataObjectDetailEntryItem		,@DataObjectBase
			method get
			proc
				mreturn mDataObjectDetailEntryItem
			endmethod
			method set
			proc
				mDataObjectDetailEntryItem = value
			endmethod
		endproperty
		

		; this will always be overridden in the vie wmodel to perform specific processing
		public virtual method LoadDetailLines,void
		proc
			nop
		endmethod

		
.endregion 


.region "Data entry event handlers"
		
		private mProgramMode		,ProgramMode
		private mLastProgramMode	,ProgramMode



		
		public method DoIsDataModified,void
			endparams
		proc

			if (!mIgnoreDataChanged)
			begin
				GridIsEnabled = !mDataObjectEntryItem.IsDataModified
				SaveCommand.ExecuteState = mDataObjectEntryItem.IsDataModified && mDataObjectEntryItem.IsDataValid
				CancelCommand.ExecuteState = mDataObjectEntryItem.IsDataModified
				DeleteCommand.ExecuteState = SelectedCollectionItem != ^null && !mDataObjectEntryItem.IsDataModified
				NewCommand.ExecuteState = !mDataObjectEntryItem.IsDataModified
				if (mDataObjectEntryItem.IsDataModified && mDataObjectEntryItem.IsDataValid && mProgramMode == ProgramMode.Enquiry)
				begin
					if (mProgramMode != ProgramMode.Add)
					begin
						mProgramMode = ProgramMode.Modify
						raiseProgramModeChanged()
					end
				end
			end

		endmethod

		private mProgramDetailMode			,ProgramMode
		private mLastProgramDetailMode		,ProgramMode


		public method DoIsDetailDataModified,void
			endparams
		proc
			if (!mIgnoreDetailDataChanged)
			begin

				DetailGridIsEnabled = !mDataObjectDetailEntryItem.IsDataModified
				SaveDetailCommand.ExecuteState = mDataObjectDetailEntryItem.IsDataModified && mDataObjectDetailEntryItem.IsDataValid
				CancelDetailCommand.ExecuteState = mDataObjectDetailEntryItem.IsDataModified
				DeleteDetailCommand.ExecuteState = SelectedDetailCollectionItem != ^null && !mDataObjectDetailEntryItem.IsDataModified
				NewDetailCommand.ExecuteState = !mDataObjectDetailEntryItem.IsDataModified
				if (mDataObjectDetailEntryItem.IsDataModified && mDataObjectDetailEntryItem.IsDataValid && mProgramDetailMode == ProgramMode.Enquiry)
				begin
					if (mProgramDetailMode != ProgramMode.Add)
						mProgramDetailMode = ProgramMode.Modify

					raiseProgramDetailModeChanged()
					if (mProgramMode != ProgramMode.Add)
					begin
						mProgramMode = ProgramMode.Modify
						raiseProgramModeChanged()
					end
				end

				if (!mDetailGridIsEnabled)
				begin
					GridIsEnabled = false
					NewCommand.ExecuteState = false
					DeleteCommand.ExecuteState = false
					CancelCommand.ExecuteState = true
					SaveCommand.ExecuteState = false
				end

			end


		endmethod

.endregion
		
.region "Standard commands"
		
		private mNewCommand				,@GenericCommand
		
		public property NewCommand		,@GenericCommand
			method get
			proc
				if (mNewCommand == ^null)
				begin
					mNewCommand = new GenericCommand("NEW", doNewCommand)
					mNewCommand.ExecuteState = true
				end
				mreturn mNewCommand
			endmethod
		endproperty
		
		private method doNewCommand,void
			sender							,@Object
			param							,string
			endparams
		proc
			DataObjectEntryItem.InitData()
			DataObjectEntryItem.InitDataPlus()
			DataObjectEntryItem.InitialValidateData()

			if (mNumberOfDetailLineSets)
			begin
				DataObjectDetailEntryItem.InitData()
				DataObjectDetailEntryItem.InitDataPlus()
				DataObjectDetailEntryItem.InitialValidateData()
				DataObjectDetailCollection.ClearCollection()
			end

			NewCommand.ExecuteState = false
			mIgnoreDataChanged = true
			DataObjectEntryItem.SetFieldEnabledStatus(true, "*ALL*")
			mIgnoreDataChanged = false
			mProgramMode = ProgramMode.Add
			raiseProgramModeChanged()
		endmethod
		
		private mSaveCommand			,@GenericCommand
		
		public property SaveCommand		,@GenericCommand
			method get
			proc
				if (mSaveCommand == ^null)
				begin
					mSaveCommand = new GenericCommand("SAVE", doSaveCommand)
					mSaveCommand.ExecuteState = false
				end
				mreturn mSaveCommand
			endmethod
		endproperty
		
		private method doSaveCommand,void
			sender								,@Object
			param								,string
			endparams
		proc

			using mProgramMode select
			(ProgramMode.Modify)			,
			begin
				;;restore the data to the colleciton item and update the file.
				SelectedCollectionItem.SynergyRecord = DataObjectEntryItem.SynergyRecord
				if (mFileAccessObject.UpdateRecordUsingGRFA(SelectedCollectionItem) != FileAccessResults.Success)
				begin
					mDataObjectEntryItem.RestoreOriginalData()
					ErrorInfo = "Synergy error : " + %string(mFileAccessObject.LastSynergyError)
					using (mFileAccessObject.LastSynergyError) select
					(54)					,ErrorDetails = ' You are trying to add a record with a key which already exists - please use a different code.'
					(431)					,ErrorDetails = 'Someone else has updated this record before you saved your changes.  Your changes have been lost.  Please try again.'
					(40)					,ErrorDetails = 'Another program is holding this record locked and your changes cannot be saved.  Please try again.'
					()						,ErrorDetails = 'Your changes have not been saved.  Please try again and refer to support if the problem persists.'
					endusing

					MoveToState(mErrorVisualState)
				end

				SaveDetailLines()

				DataObjectEntryItem.OriginalSynergyRecord = SelectedCollectionItem.SynergyRecord 
				mDataObjectEntryItem.RestoreOriginalData()
			end
			(ProgramMode.Add)				,
			begin

				; allow key value to be set in program specific view model
				SetKeyForNewRecord()

				data tmpObj						,@DataObjectBase
				mCTORArgs[1] = DataObjectEntryItem.SynergyRecord

				if (mClassConstructor == ^null)
				begin
					;;we did not use the standard/base list load capability

					data classTypeInfo			,@TypeInfo		,IntrospectionExtensions.GetTypeInfo(mDataObjectItem)
					data item					,@ConstructorInfo
					foreach item in classTypeInfo.DeclaredConstructors
					begin
						mClassConstructor = item
						if (mClassConstructor.ToString() == "Void .ctor(System.String)")
							exitloop
					end
				end
				tmpObj = (DataObjectBase)mClassConstructor.Invoke(mCTORArgs)
	
				if (mFileAccessObject.CreateRecord(tmpObj) != FileAccessResults.Success) then
				begin
					ErrorInfo = "Synergy error : " + %string(mFileAccessObject.LastSynergyError)
					using (mFileAccessObject.LastSynergyError) select
					(54)					,ErrorDetails = ' You are trying to add a record with a key which already exists - please use a different code.'
					(431)					,ErrorDetails = 'Someone else has updated this record before you saved your changes.  Your changes have been lost.  Please try again.'
					(40)					,ErrorDetails = 'Another program is holding this record locked and your changes cannot be saved.  Please try again.'
					()						,ErrorDetails = 'Your changes have not been saved.  Please try again and refer to support if the problem persists.'
					endusing
					MoveToState(mErrorVisualState)
				end
				else
				begin
					AddDetailLines()
					DataObjectCollection.AddToCollection(tmpObj)
					DataObjectEntryItem.OriginalSynergyRecord = DataObjectEntryItem.SynergyRecord 
					mDataObjectEntryItem.RestoreOriginalData()
					SelectedCollectionItem = tmpObj
				end
			end
			endusing

			raiseProgramModeChanged()
			GridIsEnabled = true
			NewCommand.ExecuteState = true
			SaveCommand.ExecuteState = false
			CancelCommand.ExecuteState = false
			DeleteCommand.ExecuteState = true
			mProgramMode = ProgramMode.Enquiry

		endmethod
		
		; dummy method which can be overridden in view models which require the ability to set automatic key(s) for new record
		public virtual method SetKeyForNewRecord,void

			endparams
		proc
			nop
		endmethod


		private mCancelCommand				,@GenericCommand
		
		public property CancelCommand		,@GenericCommand
			method get
			proc
				if (mCancelCommand == ^null)
				begin
					mCancelCommand = new GenericCommand("CANCEL", doCancelCommand)
					mCancelCommand.ExecuteState = false
				end
				mreturn mCancelCommand
			endmethod
		endproperty
		
		private method doCancelCommand,void
			sender								,@Object
			param								,string
			endparams
		proc
			mProgramMode = ProgramMode.Enquiry
			raiseProgramModeChanged()
			mDataObjectEntryItem.RestoreOriginalData()
			mDataObjectEntryItem.InitialValidateData()
			mDataObjectEntryItem.RestoreOriginalData()
			NewCommand.ExecuteState = true
			SaveCommand.ExecuteState = false
			CancelCommand.ExecuteState = false
			DeleteCommand.ExecuteState = true
			GridIsEnabled = true

		endmethod
		
		private mDeleteCommand				,@GenericCommand
		
		public property DeleteCommand		,@GenericCommand
			method get
			proc
				if (mDeleteCommand == ^null)
				begin
					mDeleteCommand = new GenericCommand("DELETE", doDeleteCommand)
					mDeleteCommand.ExecuteState = false
				end
				mreturn mDeleteCommand
			endmethod
		endproperty
		
		private method doDeleteCommand,void
			sender		,@Object
			param		,string
			endparams
		proc
			if (SelectedCollectionItem != ^null)
			begin
				if mDialogResult == ^null then
				begin
					DialogVM.Message = "Are you SURE you want to Delete this Record?."
					DialogVM.Icon = DialogIcon.Question
					DialogVM.Style = DialogStyle.YesNo
				
					MoveToState("DialogViewState")
				end
				else
				begin
					if (mFileAccessObject.DeleteRecordUsingGRFA(SelectedCollectionItem) != FileAccessResults.Success) then
					begin
						ErrorInfo = "Synergy error : " + %string(mFileAccessObject.LastSynergyError)
						MoveToState(mErrorVisualState)
					end
					else
					begin
						;;remove the item from the list

						DeleteDetailLines ()

						DataObjectCollection.Remove(SelectedCollectionItem)
						SelectedItemIndex  = 0
					
						;;init the entry object
						;					DataObjectEntryItem.InitData()
						GridIsEnabled = true
					end
					mProgramMode = ProgramMode.Enquiry
					raiseProgramModeChanged()
				end
				SaveCommand.ExecuteState = false
				CancelCommand.ExecuteState = false
				DeleteCommand.ExecuteState = true
				NewCommand.ExecuteState = true
				GridIsEnabled = true
			end
		endmethod
	


		; dummy method which can be overridden in view models which require the ability to update detail lines
		public virtual method SaveDetailLines,void

			endparams
		proc
			nop
		endmethod

		; dummy method which can be overridden in view models which require the ability to update detail lines
		public virtual method AddDetailLines,void

			endparams
		proc
			nop
		endmethod

		; dummy method which can be overridden in view models which require the ability to update detail lines
		public virtual method DeleteDetailLines,void

			endparams
		proc
			nop
		endmethod

		; dummy method which can be overridden in view models which require the ability to update on screen totals
		public virtual method UpdateTotals,void
			in req mode		,string					; mode - add, modify or delete
			endparams
		proc
			nop
		endmethod
		
.endregion

;---------------------------------------- detail lines ------------------------------------------------------------------------	
.region "detail line commands"
		
		private mNewDetailCommand			,@GenericCommand
		
		public property NewDetailCommand	,@GenericCommand
			method get
			proc
				if (mNewDetailCommand == ^null)
				begin
					mNewDetailCommand = new GenericCommand("NEW", doNewDetailCommand)
					mNewDetailCommand.ExecuteState = true
				end
				mreturn mNewDetailCommand
			endmethod
		endproperty
		
		private method doNewDetailCommand,void
			sender									,@Object
			param									,string
			endparams
		proc

			DataObjectDetailEntryItem.InitData()
			DataObjectDetailEntryItem.InitDataPlus()
			DataObjectDetailEntryItem.InitialValidateData()
			
			DataObjectDetailEntryItem.SetFieldEnabledStatus(true, "*ALL*")
			mProgramDetailMode = ProgramMode.Add	

			NewDetailCommand.ExecuteState = false

			mDeleteDetailCommand.ExecuteState = false
			mSaveDetailCommand.ExecuteState = false
			mCancelDetailCommand.ExecuteState = true		
			raiseProgramDetailModeChanged()

		endmethod
		
		private mSaveDetailCommand				,@GenericCommand
		
		public property SaveDetailCommand		,@GenericCommand
			method get
			proc
				if (mSaveDetailCommand == ^null)
				begin
					mSaveDetailCommand = new GenericCommand("SAVE", doSaveDetailCommand)
					mSaveDetailCommand.ExecuteState = false
				end
				mreturn mSaveDetailCommand
			endmethod
		endproperty
		
		private method doSaveDetailCommand,void
			sender									,@Object
			param									,string
			endparams
		proc

			using mProgramDetailMode select
			(ProgramMode.Modify)				,
			begin
				;; update totals when changing lines
				UpdateTotals('Modify')

				;;restore the data to the colleciton item
				SelectedDetailCollectionItem.SynergyRecord = DataObjectDetailEntryItem.SynergyRecord
				DataObjectDetailEntryItem.OriginalSynergyRecord = SelectedDetailCollectionItem.SynergyRecord 
				mDataObjectDetailEntryItem.RestoreOriginalData()
			end

			(ProgramMode.Add)					,
			begin
				data tmpObj							,@DataObjectBase
				;; update totals when changing lines
				UpdateTotals('Add')

				 
				mDetailCTORArgs[1] = DataObjectDetailEntryItem.SynergyRecord

				if (mDetailClassConstructor == ^null)
				begin
					;;we did not use the standard/base list load capability

					data classTypeInfo				,@TypeInfo		,IntrospectionExtensions.GetTypeInfo(mDataObjectDetailItem)
					data item						,@ConstructorInfo
					foreach item in classTypeInfo.DeclaredConstructors
					begin
						mDetailClassConstructor = item
						if (mDetailClassConstructor.ToString() == "Void .ctor(System.String)")
							exitloop
					end	
				end	
				tmpObj = (DataObjectBase)mDetailClassConstructor.Invoke(mDetailCTORArgs)
				DataObjectDetailCollection.AddToCollection(tmpObj)
					
				DataObjectDetailEntryItem.OriginalSynergyRecord = DataObjectDetailEntryItem.SynergyRecord 
				mDataObjectDetailEntryItem.RestoreOriginalData()
				SelectedDetailCollectionItem = tmpObj
				SelectedDetailItemIndex = DataObjectDetailCollection.Count

			end
			endusing
			
			mProgramDetailMode = ProgramMode.Enquiry
			raiseProgramDetailModeChanged()		

			if (SelectedDetailItemIndex >= 0) then
			begin
				DeleteDetailCommand.ExecuteState = true
				SaveDetailCommand.ExecuteState = false
				CancelDetailCommand.ExecuteState = false
			end
			else
			begin
				DeleteDetailCommand.ExecuteState = false
				SaveDetailCommand.ExecuteState = false
				CancelDetailCommand.ExecuteState = false
			end
			NewDetailCommand.ExecuteState = true

			DetailGridIsEnabled = true

			if (mDataObjectEntryItem.IsDataValid)
				SaveCommand.ExecuteState = true
			CancelCommand.ExecuteState = true
			NewCommand.ExecuteState = false
			DeleteCommand.ExecuteState= false
			GridIsEnabled = false

			if (mProgramMode == ProgramMode.Enquiry)
			begin
				mProgramMode = ProgramMode.Modify
				raiseProgramModeChanged()
			end

		endmethod
		

		private mCancelDetailCommand			,@GenericCommand
		
		public property CancelDetailCommand		,@GenericCommand
			method get
			proc
				if (mCancelDetailCommand == ^null)
				begin
					mCancelDetailCommand = new GenericCommand("CANCEL", doCancelDetailCommand)
					mCancelDetailCommand.ExecuteState = false
				end
				mreturn mCancelDetailCommand
			endmethod
		endproperty
		
		private method doCancelDetailCommand,void
			sender									,@Object
			param									,string
			endparams
		proc
			mDataObjectDetailEntryItem.RestoreOriginalData()
			mDataObjectDetailEntryItem.InitialValidateData()
			mDataObjectDetailEntryItem.RestoreOriginalData()

			mProgramDetailMode = ProgramMode.Enquiry
			raiseProgramDetailModeChanged()
			
			NewDetailCommand.ExecuteState = true


			DeleteDetailCommand.ExecuteState = true
			SaveDetailCommand.ExecuteState = false
			CancelDetailCommand.ExecuteState = false

			NewDetailCommand.ExecuteState = true
			DetailGridIsEnabled = true

		endmethod
		
		private mDeleteDetailCommand			,@GenericCommand
		
		public property DeleteDetailCommand		,@GenericCommand
			method get
			proc
				if (mDeleteDetailCommand == ^null)
				begin
					mDeleteDetailCommand = new GenericCommand("DELETE", doDeleteDetailCommand)
					mDeleteDetailCommand.ExecuteState = false
				end
				mreturn mDeleteDetailCommand
			endmethod
		endproperty
		
		private method doDeleteDetailCommand,void
			sender								,@Object
			param								,string
			endparams
		proc
			if (SelectedDetailCollectionItem != ^null)
			begin
				;; update totals when deleting lines
				UpdateTotals('Delete')

				;;remove the item from the list
				DataObjectDetailCollection.Remove(SelectedDetailCollectionItem)
				SelectedDetailCollectionItem  = ^null
					
				;;init the entry object
				DataObjectDetailEntryItem.InitData()

			end

			mProgramDetailMode = ProgramMode.Enquiry
			raiseProgramDetailModeChanged()
			
			if (SelectedDetailItemIndex) then
			begin
				DeleteDetailCommand.ExecuteState = true
				SaveDetailCommand.ExecuteState = false
				CancelDetailCommand.ExecuteState = false
			end
			else
			begin
				DeleteDetailCommand.ExecuteState = false
				SaveDetailCommand.ExecuteState = false
				CancelDetailCommand.ExecuteState = false
			end
			NewDetailCommand.ExecuteState = true
			DetailGridIsEnabled = true			
			SaveCommand.ExecuteState = true
			CancelCommand.ExecuteState = true
			NewCommand.ExecuteState = false
			DeleteCommand.ExecuteState= false
			GridIsEnabled = false

			if (mProgramMode == ProgramMode.Enquiry)
			begin
				mProgramMode = ProgramMode.Modify
				raiseProgramModeChanged()
			end

		endmethod

.endregion

		
.region "list/grid options"
		
		private mGridIsEnabled				,boolean		,true
		
		public property GridIsEnabled		,boolean
			method get
			proc
				mreturn mGridIsEnabled
			endmethod
			method set
			proc
				if (mGridIsEnabled != value)
				begin
					mGridIsEnabled = value
					RaisePropertyChanged("GridIsEnabled")
				end
			endmethod
		endproperty


		private mDetailGridIsEnabled			,boolean		,true
		
		public property DetailGridIsEnabled		,boolean
			method get
			proc
				mreturn mDetailGridIsEnabled
			endmethod
			method set
			proc
				if (mDetailGridIsEnabled != value)
				begin
					mDetailGridIsEnabled = value
					RaisePropertyChanged("DetailGridIsEnabled")
				end
			endmethod
		endproperty
		
		
.endregion
		
.region "Error information"
		
		private mErrorInfo				,string
		
		public property ErrorInfo		,string
			method get
			proc
				mreturn mErrorInfo
			endmethod
			method set
			proc
				mErrorInfo = value
				RaisePropertyChanged("ErrorInfo")
			endmethod
		endproperty
		
		private mErrorDetails			,string
		
		public property ErrorDetails	,string
			method get
			proc
				mreturn mErrorDetails
			endmethod
			method set
			proc
				mErrorDetails = value
				RaisePropertyChanged("ErrorDetails")
			endmethod
		endproperty	
.endregion

.region "Dialog Control Detail"
		
		private mDialogVM		,@Symphony.Conductor.ViewModel.DialogControlViewModel
		private mDialogResult	,@DialogResult
		
		private method configureDialog	,void
			sender						,@FrameworkElement
			endparams
		proc
			mDialogVM = new DialogControlViewModel(sender)
			mDialogVM.Title = "SFE Project"
			mDialogVM.Icon = DialogIcon.Exclamation
			mDialogVM.Style = DialogStyle.OK
			
			lambda doCloseDialog(result)
			begin
				mDialogResult = result
				this.StateCompleted()
			end
			addhandler(mDialogVM.DialogProcessed, doCloseDialog)
			
		endmethod
		
		public property DialogVM, @Symphony.Conductor.ViewModel.DialogControlViewModel
			method get
			proc
				mreturn mDialogVM
			endmethod
			method set
			proc
				mDialogVM = value
				RaisePropertyChanged("DialogVM")
			endmethod
		endproperty
		
		
.endregion
	endclass
	
endnamespace
