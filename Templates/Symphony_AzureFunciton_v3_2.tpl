<CODEGEN_FILENAME><Structure_name>s.AzureFunction.CodeGen.cs</CODEGEN_FILENAME>
<REQUIRES_USERTOKEN>PROCEDURENAMESPACE</REQUIRES_USERTOKEN>
;//****************************************************************************
;//
;// Title:  	 Symphony_AzureFunciton_v3_2.tpl
;//
;// Type:   	 CodeGen Template
;//
;// Description: Template to define an Azure Serverless Function
;//
;// Author: 	 Richard C. Morris, Synergex Technology Evangelist
;//
;// Copyright (c) 2017, Synergex International, Inc. All rights reserved.
;//
;// Redistribution and use in source and binary forms, with or without
;// modification, are permitted provided that the following conditions are met:
;//
;// * Redistributions of source code must retain the above copyright notice,
;//   this list of conditions and the following disclaimer.
;//
;// * Redistributions in binary form must reproduce the above copyright notice,
;//   this list of conditions and the following disclaimer in the documentation
;//   and/or other materials provided with the distribution.
;//
;// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;// POSSIBILITY OF SUCH DAMAGE.
;//
;//****************************************************************************
//****************************************************************************
// WARNING: This code was generated by CodeGen. Any changes that you
//  		make to this code will be overwritten if the code is regenerated!
//
// Template author: Richard C. Morris, Synergex Technology Evangelist
//
// Template Name:   Symphony Framework : <TEMPLATE>.tpl
//
//***************************************************************************
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Threading.Tasks;
using Microsoft.Azure.WebJobs;
using Microsoft.Azure.WebJobs.Extensions.Http;
using Microsoft.Azure.WebJobs.Host;
using Symphony.Harmony;
using System.Net.Http.Formatting;
using System;

namespace <NAMESPACE>
{
    public static class <Structure_name>s
    {
        [FunctionName("<Structure_name>s")]
        public static async Task<HttpResponseMessage> Run([HttpTrigger(AuthorizationLevel.Function, "get", "post", Route = null)]HttpRequestMessage req, TraceWriter log)
        {
            List<<Structure_name>_Data> response = null;
            string responseMessage = "";

            //connect to Symphony Bridge
            DBConnector connection = <NAMESPACE>.GlobalSymphonyConnector.Connection;

            //check if this is a procedure call
            string procs = req.GetQueryNameValuePairs()
                .FirstOrDefault(q => string.Compare(q.Key, "procedure", true) == 0)
                .Value;

            if (!string.IsNullOrEmpty(procs))
            {
                try
                {
                    //do we have parameters?
                    string param = req.GetQueryNameValuePairs()
                        .FirstOrDefault(q => string.Compare(q.Key, "param", true) == 0)
                        .Value;

					//do we have fields?
					string fields = req.GetQueryNameValuePairs()
						.FirstOrDefault(q => string.Compare(q.Key, "fields", true) == 0)
						.Value;

                    var serverResponse = await DataExecute.RunDataExecute(connection
                        , "exec @<PROCEDURENAMESPACE>." + procs
                        , new <Structure_name>_Data()
						, Parameters.BuildParameterArray(param));
//						, fields);     

                    response = serverResponse.OfType<<Structure_name>_Data>().ToList();
                }
                catch (System.Exception e)
                {
                    responseMessage = e.Message;
                }
            }
            else
            {
                // parse query parameter to determine if they are requesting seelcted fields
                string fields = null;
				
                // parse query parameter to determin if they are requesting seelcted fields
                string limit = null;
				
                //have they specified a where/filter value?
                string filters = null;
				Object[] filterValues = null;
				
                //have they specified an orderby value?
                string orderByDirection = "";
                string orderBy = null;

                //have they specified an case controling?
                string casing = null;

                foreach (KeyValuePair<string, string> item in req.GetQueryNameValuePairs())
                {
                    switch (item.Key)
                    {
                        case "fields":
                            fields = item.Value;
                            break;
                        case "limit":
                            limit = item.Value;
                            break;
                        case "filter":
                            filters = item.Value;
                            break;
                        case "sort":
                            orderBy = item.Value;
                            if (!string.IsNullOrEmpty(orderBy))
                            {
                                if (orderBy.Substring(0, 1) == "-")
                                    orderByDirection = " DESC";
                                else
                                    orderByDirection = " ASC";
                            }
                            break;
                        case "casing":
                            casing = item.Value;
                            break;
                        default:
                            //unknown.  If the "value" is null then it's the key value
                            if (string.IsNullOrEmpty(item.Value) == true)
                            {
								filters = "";
<PRIMARY_KEY>
								filterValues = new Object[<KEY_SEGMENTS>];
</PRIMARY_KEY>
								string connector = "";
								int segNumber = 0;
                                var idSplit = item.Key.Split(',');
                                try
                                {
<PRIMARY_KEY>
<SEGMENT_LOOP>
								    filters = filters +  connector + " <SEGMENT_NAME> = :<SEGMENT_NUMBER>";
									filterValues[<SEGMENT_NUMBER> - 1] = idSplit[<SEGMENT_NUMBER> - 1];

									segNumber += 1;
									if (segNumber != <KEY_SEGMENTS>)
										connector  = " and ";
									else
										connector  = "";
</SEGMENT_LOOP>
</PRIMARY_KEY>
                                }
                                catch (Exception)
                                {
                                    responseMessage = "All required primary key segment data not provided";
                                }
                            }
                            break;
                    }
                }

                //Get request body
                //dynamic data = await req.Content.ReadAsAsync<object>();

                if (!string.IsNullOrEmpty(casing) && casing.ToUpper() == "FALSE")
                    connection.SetCaseSensitivity(false);

				if (string.IsNullOrEmpty(responseMessage))
				{
					try
					{
					if (filterValues == null)
					{
						var serverResponse = await DataSelect.RunDataSelect(connection,
							string.Format("select {0} {1} from <Structure_name> {2} {3} {4}"
						, limit == null ? string.Empty : "top " + limit, fields ?? " * "
						, filters == null ? string.Empty : "where " + filters
						, orderBy == null ? string.Empty : "order by " + orderBy.Replace("-", "").Replace("+", "")
						, orderByDirection)
						, new <Structure_name>_Data());

						response = serverResponse.OfType<<Structure_name>_Data>().ToList();
					}
					else
					{
						var serverResponse = await DataSelect.RunDataSelect(connection,
							string.Format("select {0} {1} from <Structure_name> {2} {3} {4}"
						, limit == null ? string.Empty : "top " + limit, fields ?? " * "
						, filters == null ? string.Empty : "where " + filters
						, orderBy == null ? string.Empty : "order by " + orderBy.Replace("-", "").Replace("+", "")
						, orderByDirection)
						, new <Structure_name>_Data()
						, filterValues);

						response = serverResponse.OfType<<Structure_name>_Data>().ToList();
					}

						//sort out which columns we want to return
						if (fields != null)
						{
							string[] separators = { "," };
							<Structure_name>_Data.DefineSerialiazableCSElements(fields.Split(separators, StringSplitOptions.RemoveEmptyEntries));
						}
						else
						{
							<Structure_name>_Data.DefineSerialiazableCSElements(null);
						}
					}
					catch (System.Exception e)
					{
						responseMessage = e.Message;
					}
				}
            }

            //sort out the response data
            var formatter = new JsonMediaTypeFormatter();
            var json = formatter.SerializerSettings;
            json.ContractResolver = new Symphony.Harmony.Core.CSharpContractResolver();

            return response == null
                ? req.CreateResponse(HttpStatusCode.BadRequest, responseMessage)
                : req.CreateResponse(HttpStatusCode.OK, response, formatter);

        }
    }
}

